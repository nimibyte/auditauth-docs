# Token Exchange Flow

The token exchange flow defines how an authorization code is converted into an authenticated session.

This flow is security-critical.

It validates identity, enforces application boundaries, and issues signed access tokens.

---

## High-Level Flow

1. User is redirected to login.
2. Authentication provider returns an authorization `code`.
3. BFF receives the code at:
   ```
   /api/auditauth/callback
   ```
4. BFF calls upstream:
   ```
   POST /v1/auth/authorize
   ```
5. Upstream validates the code.
6. Access and refresh tokens are issued.
7. Cookies are set.
8. User is redirected to configured redirectUrl.

---

## Authorization Code

The callback receives:

- `code` (authorization code)

This code:

- Has expiration
- Can be used only once
- Tracks `used_at` internally

Replay Protection:

- Code reuse is prevented.
- Expired codes are rejected.
- `used_at` ensures one-time exchange.

If validation fails:

- 401 Unauthorized is returned.
- BFF redirects to invalid auth page.

---

## Firebase Token Validation

During exchange, the backend:

- Receives Firebase `id_token`
- Calls:
  ```
  firebaseAuth.verifyIdToken(idToken)
  ```

Verified claims:

- iss
- aud
- exp
- iat

Nonce verification:

- Not explicitly implemented in current code.

If validation fails:

- UnauthorizedException is thrown.
- HTTP 401 is returned.

---

## Access Token Issuance

After successful validation:

- Access token is generated.
- Signed with RS256.
- kid: "main"

Access token contains:

- sub
- email
- aud
- iss
- app_id
- account_id
- iat
- exp
- custom claims (plan, avatar, name)

Access token TTL:

- 30 minutes

---

## Refresh Token Issuance

Refresh token:

- Opaque token
- Random bytes (hex)
- Hashed in database
- Bound to session record
- Rotated on every refresh

Refresh TTL:

- 5 days (sliding)

Refresh token is:

- httpOnly cookie (browser flow)
- Can be passed in body (server flow)

---

## Session Creation

During exchange:

- Session record is created or upserted.
- Session is tied to:
  - identity
  - scope
  - refresh_token_hash

Multiple concurrent sessions per identity scope are not supported.

Session revocation marks:

- `revoked_at` timestamp

---

## Failure Scenarios

Possible failures:

- Invalid authorization code → 401
- Expired authorization code → 401
- Firebase token invalid → 401
- Application invalid → 401 or 404
- Identity disabled → 401

All failures return:

```
{
  statusCode: number,
  message: string,
  error: string
}
```

(Based on Nest default exception format.)

---

## Redirect Behavior

BFF does not return tokens in body.

Instead:

- Sets cookies
- Redirects user

If exchange fails:

- Redirects to configured invalid page.

---

## Security Boundaries

Security guarantees in exchange flow:

- One-time authorization code
- Firebase claim verification
- RS256-signed access tokens
- Refresh token hashing
- Session-bound refresh rotation

Limitations in Beta:

- No nonce validation in app layer
- No JWKS endpoint
- Static signing key (kid: "main")

---

## Trust Boundary Summary

Exchange validates:

- Identity provider trust (Firebase)
- Application identity (appId)
- API key (where applicable)
- Authorization code uniqueness

After exchange:

- Runtime middleware enforces identity state.
- Plan enforcement applies to features.

Token validity alone does not guarantee access.

---

## Next Step

Continue with:

- Session Endpoints
