# Access Control Model

Access control in AuditAuth is evaluated at runtime.

It is not purely token-based.

It is not purely role-based.

It is state-aware and plan-aware.

Every protected interaction is evaluated against current governance state.

---

## Control Dimensions

Access decisions may depend on:

- Identity state
- Application state
- Plan permissions
- Session revocation status
- Feature access flags

These dimensions are evaluated per request.

---

## Identity-Level Control

Each identity can be enabled or disabled.

When an identity is disabled:

- Login is blocked.
- Token exchange is rejected.
- Middleware validation prevents access.
- Portal access is denied.

Access tokens may remain valid until expiration (maximum 30 minutes).

However, middleware validation ensures real-time blocking.

Access control is not limited to JWT expiration.

It is enforced dynamically.

---

## Session-Level Control

Sessions are linked to refresh tokens.

When logout occurs:

- Session is marked revoked.
- Refresh token is invalidated.
- Further refresh attempts fail.

Access tokens issued before revocation may remain cryptographically valid.

Middleware validation enforces session revocation in practice.

Session control is runtime-enforced.

---

## Application-Level Control

Applications have lifecycle states:

- active
- past_due
- suspended

Application state impacts:

- Authentication availability
- Portal access
- Dashboard visibility
- Metrics ingestion

Grace period behavior (e.g. past_due) is handled by deterministic rules.

Suspended applications are blocked immediately.

---

## Plan-Level Control

Plans define feature access:

- Authentication providers
- MFA availability
- Metrics access
- Audit retention
- Dashboard visibility
- Whitelabel configuration

Feature gating is enforced:

- During authentication configuration
- During ingestion
- During dashboard access
- During runtime feature checks

Plan changes affect future behavior only.

Historical data is not rewritten.

---

## Middleware Enforcement

Middleware performs:

- Identity validation
- Session validation
- Application state validation

Even with a valid JWT:

- Disabled identities are blocked.
- Suspended applications are blocked.

Access is evaluated dynamically.

---

## Dashboard Gating

Dashboard visibility is controlled via:

- `feature_access.dashboard_overview`
- `feature_access.dashboard_navigation`
- `feature_access.dashboard_requests`
- `feature_access.dashboard_sessions`

Stored data may exist but remain inaccessible through UI.

Access control governs visibility, not storage existence.

---

## Metrics Ingestion Control

Metrics ingestion requires:

- Valid `apiKey`
- Valid `appId`

Metrics do not require user authentication.

Observability operates at application boundary.

Identity-level access control does not block metrics ingestion automatically.

---

## Enforcement Gaps (Beta)

Current Beta implementation:

- Does not log all access denial events.
- Does not produce centralized enforcement audit trails.
- Does not include a policy engine abstraction.

Access control is embedded in runtime layers.

Future versions may introduce:

- Policy abstraction
- Centralized enforcement logging
- Fine-grained audit of denied access

---

## Architectural Philosophy

Access control in AuditAuth is:

- Deterministic
- Runtime-evaluated
- State-aware
- Plan-aware
- Infrastructure-aligned

It avoids:

- Static token-only validation
- Complex role hierarchies
- Distributed policy orchestration

Governance is enforced where interaction occurs.

---

## Next Step

To understand transparency boundaries and governance visibility, continue with:

- Operational Transparency
