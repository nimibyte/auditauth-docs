# Refresh & Sliding Expiration

Refresh logic governs session continuity in AuditAuth.

Access tokens are intentionally short-lived (30 minutes).

Refresh tokens extend identity continuity in a controlled, stateful manner.

The refresh mechanism is:

- Session-bound
- Rotating
- Sliding
- Deterministic

---

## When Refresh Happens

Refresh is triggered when:

- An access token expires
- A protected API returns `401 Unauthorized`

In SDK integrations:

- Web and Next.js SDKs automatically attempt refresh on `401`
- The developer does not need to manually manage token renewal

Refresh behavior is consistent across supported SDKs.

---

## Refresh Flow (Browser Context)

In browser-based flows:

- Refresh token is stored in an httpOnly cookie
- Cookie is sent automatically with the refresh request
- A new access token is returned in the response body
- A new refresh token is set in the cookie
- The previous refresh token becomes invalid

Access tokens are not stored in httpOnly cookies.

They are used via `Authorization` header.

---

## Refresh Flow (Server / Non-Browser)

In non-browser environments:

- Refresh token may be transmitted in the request body
- A new access token is returned
- A new refresh token is returned
- The previous refresh token becomes invalid

The integrator is responsible for secure storage outside browser contexts.

---

## Refresh Rotation

Refresh tokens are rotated on every refresh.

This means:

- Each refresh generates a new refresh token
- The stored hash in the session is replaced
- The previous refresh token becomes immediately invalid

Rotation prevents replay attacks.

If a stolen refresh token is reused:

- It will fail after the first legitimate refresh
- The session remains secure

---

## Sliding Expiration Model

Session expiration is sliding.

Each successful refresh:

- Updates `expires_at`
- Extends session lifetime by ~5 days

If no refresh occurs within the expiration window:

- The session expires naturally
- Re-authentication is required

This provides:

- Good user experience
- Reduced login friction
- Controlled session duration

---

## No Absolute Lifetime (Beta)

In the current Beta implementation:

- There is no absolute maximum session lifetime
- Active sessions can persist indefinitely if continuously refreshed

This may change in future stable releases.

---

## Rate Limiting

The refresh endpoint is rate-limited.

This protects against:

- Brute force attempts
- Automated abuse
- Excessive refresh loops

Rate limiting is enforced at the API layer.

---

## Failure Scenarios

Refresh fails if:

- Refresh token is expired
- Session is revoked
- Session is past expiration
- Lifecycle state prevents refresh
- Refresh token does not match stored hash

On failure:

- SDK does not silently retry indefinitely
- Re-authentication is required

Failure is explicit.

---

## Plan Downgrade Behavior

Refresh is not blocked by plan downgrade.

However:

- Feature access may change
- Enforcement may restrict capabilities
- Lifecycle state may override refresh eligibility

Refresh governs identity continuity.

Feature enforcement governs capability access.

These concerns remain separate.

---

## Security Characteristics

The refresh model provides:

- Replay resistance via rotation
- Bounded access token exposure
- Stateless API validation
- Controlled long-term session state

It avoids:

- Persistent access token storage
- Token introspection dependency
- Global revocation lists

---

## Architectural Trade-Off

Access tokens are not invalidated immediately on session revocation.

They remain valid until expiration (30 minutes).

This trade-off:

- Eliminates distributed blacklist complexity
- Preserves API scalability
- Limits exposure window to short TTL

Refresh control governs session termination.

---

## Deterministic Continuity

Session continuity exists only if:

- Refresh token is valid
- Session is not revoked
- Session is not expired
- Application lifecycle state allows operation

There is no hidden fallback.

Refresh is the single continuity mechanism.

---

## Next Step

To understand how identity can be explicitly invalidated, continue with:

- Revocation Model
