# Trust Boundaries

Trust Boundaries define how identity flows between domains, cookies, headers, and services.

AuditAuth explicitly separates:

- Authentication domain
- Application domain
- Backend verification boundary

Identity validation and application logic do not share trust implicitly.

---

## Domain Separation

In production environments:

- Authentication API runs under a dedicated domain (e.g. `api.auditauth.com`)
- The public application runs under a separate domain (e.g. `auditauth.com`)
- Client applications integrating AuditAuth operate under their own domains

This separation ensures:

- Authentication cookies are scoped appropriately
- Cross-origin requests are explicit
- Session boundaries are controlled

There is no implicit shared session between unrelated domains.

---

## Refresh Token Storage (Browser Flow)

In browser contexts:

- Refresh tokens are stored in httpOnly cookies
- Cookies are marked `Secure` in production
- SameSite policy:
  - `None` in production for cross-domain auth
  - `Lax` in non-production environments

Because refresh tokens are:

- httpOnly
- Not accessible via JavaScript
- Automatically transmitted by the browser

They are protected against common XSS exfiltration vectors.

---

## Access Token Transmission

Access tokens are:

- Returned in response bodies
- Stored client-side (SDK-managed)
- Sent via `Authorization: Bearer <token>` header

Access tokens are not stored in httpOnly cookies.

This separation ensures:

- Clear authentication vs authorization boundary
- No implicit credential forwarding
- Explicit protected request behavior

---

## Backend Verification Boundary

Backends validate access tokens locally using:

- RS256 signature verification
- Public key
- Claim validation (`iss`, `aud`, `exp`, `app_id`)

No runtime introspection call is required.

This ensures:

- No dependency on central auth service during request validation
- High-performance protected endpoints
- No per-request database lookup

Validation is cryptographic and self-contained.

---

## Refresh Endpoint Boundary

Refresh operations:

- Require valid refresh token
- Require active session
- Require non-expired session
- Require non-revoked session

Refresh is the only operation that depends on database session state.

All other protected requests are stateless.

---

## SDK Trust Model

SDKs:

- Do not store refresh tokens in accessible storage
- Automatically handle refresh on `401`
- Do not expose internal refresh tokens
- Enforce redirect boundaries during authentication

The SDK does not replace server validation.

Server validation remains mandatory.

---

## Lifecycle State Boundary

Application lifecycle state is evaluated before issuing new tokens.

If application is:

- Suspended
- Cancelled
- Restricted (post-grace)

Refresh may be denied.

Trust is conditional on application operational eligibility.

---

## Separation of Concerns

AuditAuth enforces:

- Authentication responsibility within auth domain
- Authorization responsibility within application backend
- Subscription enforcement at token issuance and refresh boundary

Identity proof does not override operational eligibility.

Each boundary is evaluated independently.

---

## Security Characteristics

Trust boundary design provides:

- Minimal cross-domain leakage
- Explicit token handling
- Clear refresh control point
- Stateless request validation
- Reduced attack surface

It avoids:

- Shared global sessions
- Hidden credential forwarding
- Implicit trust between domains

All trust boundaries are explicit.

---

## Limitations (Beta)

In Beta:

- No JWKS endpoint
- No multi-key rotation
- No dynamic key discovery
- No token binding to device fingerprint

Future stable releases will expand key management capabilities.

Trust separation philosophy remains unchanged.

---

## Next Step

To understand how signing keys are handled and what the current limitations are, continue with:

- Key Management
