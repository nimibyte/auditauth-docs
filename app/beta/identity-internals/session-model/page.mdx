# Session Model

The Session Model is the stateful foundation of identity continuity in AuditAuth.

While access tokens are stateless and self-contained, session persistence governs:

- Refresh eligibility
- Revocation
- Sliding expiration
- Long-term identity continuity

Sessions are stored in the database.

Access tokens are not.

---

## Session as Identity Anchor

A session represents:

- A verified identity
- Within a specific application scope
- With an associated refresh token

Each session contains:

- `identity_id`
- `app_id`
- `refresh_token_hash`
- `expires_at`
- `revoked_at` (nullable)

The session record is the source of truth for refresh eligibility.

---

## Single-Session Constraint (Per Scope)

AuditAuth enforces a single active session per identity per application scope.

When a new login occurs:

- The session is upserted.
- Previous refresh token becomes invalid.
- The session record is updated.

This prevents uncontrolled session multiplication.

It simplifies revocation logic.

---

## Session Creation

A session is created when:

- Authentication succeeds
- MFA requirements (if any) are satisfied
- Tokens are issued

At creation:

- A refresh token is generated
- The refresh token is hashed
- The hash is stored in the session record
- `expires_at` is set (~5 days)

The refresh token itself is never stored in plaintext.

---

## Refresh Token Binding

Refresh tokens are:

- Opaque random values
- Bound to a specific session
- Rotated on every refresh

On refresh:

1. The provided refresh token is hashed.
2. The hash is compared to the stored hash.
3. If valid and not expired:
   - A new refresh token is generated.
   - The hash is replaced.
   - `expires_at` is extended.

Previous refresh tokens immediately become invalid.

This prevents token replay.

---

## Sliding Expiration

Session expiration is sliding.

Each successful refresh:

- Extends `expires_at` by ~5 days
- Keeps active sessions alive
- Allows inactive sessions to expire naturally

There is no absolute maximum lifetime in Beta.

Sessions can persist indefinitely if continuously refreshed.

---

## Session Revocation

A session may be revoked via:

- Logout
- Administrative action
- Lifecycle state enforcement

Revocation sets:

- `revoked_at`

Once revoked:

- Refresh attempts fail
- No new access tokens are issued

Access tokens already issued remain valid until expiration.

---

## Logout Behavior

Logout:

- Marks the session as revoked
- Invalidates the current refresh token
- Emits an audit event

It does not invalidate access tokens immediately.

This is by design.

---

## Expiration Behavior

If `expires_at` is reached:

- Refresh fails
- Session is effectively terminated
- Re-authentication is required

Expired sessions are not automatically deleted.

They simply become unusable.

---

## No Global Session Store Dependency

Session validation occurs only during refresh.

Access token validation does not require database lookup.

This separation ensures:

- High performance for protected APIs
- No database dependency per request
- Horizontal scalability

The session database is consulted only for refresh operations.

---

## Security Characteristics

The session model provides:

- Rotating refresh tokens
- Replay resistance
- Explicit revocation boundary
- Deterministic state transitions

It avoids:

- Global blacklists
- Token introspection endpoints
- Distributed revocation tracking

Session state is minimal but sufficient.

---

## Architectural Implications

Because access tokens are stateless:

- Revocation is bounded by expiration time (30 minutes)
- Immediate access token invalidation is not supported in Beta

Long-term session control is governed by:

- Refresh eligibility
- Session state
- Lifecycle state

---

## Next Step

To understand how refresh rotation and sliding expiration work in detail, continue with:

- Refresh & Sliding Expiration
